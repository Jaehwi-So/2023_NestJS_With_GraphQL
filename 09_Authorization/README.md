# 세션

- 로그인 시 세션 ID를 클라이언트에게 넘겨줌
- 클라이언트는 세션ID를 변수나 로컬 스토리지 혹은 쿠키에 저장
- 세션 ID의 사용자 정보는 서버에 저장
- API 이용 시 세션 ID를 같이 전달하여 인증 후 Response 반환
- 문제점
  - 사용자가 많을 시 서버 메모리 할당의 문제점
  - 인증 서버의 메모리를 증가시켜 해결(Scale up)
  - 인증 서버를 분산시켜 해결(Scale out)
    - 각각의 백엔드 컴퓨터가 각각의 상태(세션 유무)를 가지고 있어 공유되지 않는 stateful한 상태 발생
    - 세션 정보를 데이터베이스에서 관리하여 stateless 상태로 변경
    - DB의 uuid(tokenID)를 클라이언트에 인증 완료 시 전달, 클라는 토큰 ID를 요청 시 같이 전송
    - 백엔드의 부하는 막았지만 데이터베이스의 부하 발생 -> 데이터베이스도 분산? -> 어떻게 공유할 것인가?
      - 데이터베이스의 샤딩과 파티셔닝
      - 테이블 파티셔닝 : 수평(로우들을 분산 == 데이터베이스 샤딩)/수직(컬럼들을 분산)으로 잘라서 보관
      - 1번부터 100번, 101번부터 200번까지의 데이터를 다른 데이터베이스에 분산하여(샤딩) 번호에 따라 다른 데이터베이스를 참조하도록
      - 메모리 전용 데이터베이스의 사용 : Redis
      - 여러개의 Redis에 분산하여 로그인하는 방식

# JWT 토큰 인증방식

- 로그인 정보를 DB에 저장하지 말고 암호화된 Object에 저장하자는 아이디어

1. 브라우저의 로그인 요청(인증 : Authentication)
2. 인증되었을 시 이메일 등 사용자 정보와 토큰 만료시간 등을 담은(복호화하여 내용 조회가 가능하기에 중요 데이터 X) 객체를 암호화하여 전달
3. 클라이언트는 토콘을 변수나 로컬 스토리지 혹은 쿠키에 저장
4. 요청 시 해당 토큰을 함께 전달 (인가 : Authorization)
5. 서버에서 복호화하여 만료시간과 사용자 정보가 인증되었을 시 Response 반환

- JWT는 보는 것은 가능하지만 조작하는 것이 불가능하다.
- 토큰 탈취의 위험으로 클라이언트는 HTTP Header에 포함하여 전송(Authorization: Bearer xxx)하며, 만료 시간을 지정하고, Refresh해주어야 한다.
